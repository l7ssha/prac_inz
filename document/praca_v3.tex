\documentclass[12pt,a4paper]{article}

\usepackage{minted}
\usepackage[T1]{fontenc}
\usepackage{url}
\usepackage{color,soul}
\usepackage{caption}
\usepackage{biblatex}
\usepackage{float}

\newfloat{code}{h}{loa}
\captionsetup[code]{name=Program}

\addbibresource{sources.bib}

\captionsetup[table]{name=Tabela}
\renewcommand*\contentsname{Spis treści}
\renewcommand{\listtablename}{Spis tabel}

\title{Stacja pogodowa oparta na mikrokontrolerze ESP32 z interfejsem użytkownika oraz API}
\author{Szymon Uglis}

\begin{document}

\nocite{*}

% \begin{titlepage}
%     \maketitle
% \end{titlepage}

\tableofcontents{}
\pagebreak

\section{Wstęp}

\subsection{Wprowadzenie}

Dzięki szerokiemu dostępowi do internetu mamy łatwy dostęp do danych pogodowych aktualnych jak i historycznych z całego świata. Istnieje wiele
serwisów, programów telewizyjnych, które aktualne dane pogodowe, prognozy pogody prezentują nam w przystępny sposób.
Problemem z poleganiem na danych pogodowych z popularnych serwisów jest relatywnie niska dokładność aktualnych warunków pogodowych jak i prognoz pogody.
Bowiem serwisy te nie mogą mieć stacji pogowowych rozstawionych co na przykład kilometr, aby dokładność dla każdego potencjalnego zainteresowana była wysoka.
Dlatego polega się w dużym stopniu na ogólnych danych z kilku, bądź kilkunatstu stacji w danym regionie, aby wykonać ekstrapolację dla
aktualnych warunków pogodowych dla całego regionu. 
Serwisy udostępniające dane pogodowe dla lokalizacji są tylko przybliżeniem faktycznych stanu jaki znajduje sie w danym miejscu. 

\subsection{Cel projektu}

Celem projektu jest zbadanie przydatności modułu ESP32 oraz kompatybilnych komponentów do celów kolekcji danych pogodowych. 
Rezultatem będzie utworzenie urządzenia opartego na systemie wbudwanym pozwalającym na wielofunkcyjny pomiar parametrów pogodowych oraz udostępnianie ich za pomocą witryny www.

Urządzenie, będzie udostępniało również interfejs programistyczny API REST, które będzie umożliwiało integracje oraz dalszy rozwój projektu 
(np. integracja z systemem home assitant czy innymi urządzeniami Internetu rzeczy (IoT))

\subsection{Opis rozwiązania tworzonego w ramach projektu}

Narzędzie będzie składać sie z mikrokontrolera ESP-WROOM-32 oraz czujników pozwalająych kolekcje danych pogodowych (temperatury, ciśnienia, natężenia światła, wskaźnika UV)

\paragraph{Funkcje urządzenia}
\begin{itemize}
    \item Pomiar oraz kalkulacja danych pogodowych na podstawie danych wejściowych z czujników
    \item Udostępnienie i agregacja danych na stronie www
    \item Udostępnienie interfejsu programistycznego REST
    \item Możliwość zmiany parametrów odczytów sensorów
\end{itemize}

\section{Środowisko programowe}
Do implementacji systemu wbudowanego wykorzystane zostaną:
\begin{itemize}
    \item Język C do utworzenia oprogramowania mikrokontrolera
    \item Język HTML oraz CSS do utworzenia interfejsu www
    \item Środowisko programistyczne Arduino Studio w wersji 2.2.1
\end{itemize}

\subsection{mDNS}

W projekcie zostanie wykorzystany protokół mDNS

\section{Konfiguracja sprzętowa}

\begin{itemize}
    \item Mikrokontroler - ESP-WROOM-32
    \item Czujnik natężenia światła - TSL25911
    \item Czujnik temperatury i wilgotności powietrza - DHT22
    \item Czujnik ciśnienia oraz temperatury - DPS310
    \item Czujnik światła ultrafioletowego - LTR390
\end{itemize}

\subsection{ESP-WROOM-32}
ESP-WROOM-32 (albo ESP32-WROOM-32) to mikrokontroler ze zintegrowanym WIFi oraz bluetooth. Nadaje się do szerokiej gamy zastosowań:
od kontrolera czujników z niskim poborem energii do zaawansowanych zadań enkodowania sygnałów głosowych czy muzyki.

Moduły bazujące na rdzeniach ESP32 zyskały popularność ze wzklędu na zaintegrowaną obsługę WIFI, 
niskim kosztom oraz bogatej dokumentacji oraz wielu możliwych integracji.

Mikrokontroler znajdzie zastosowanie w prostych jak i bardziej skomplikowanych projektach, dzięki dwóm rdzenion, które mogą być kontrolowane osobno,
szerokich możliwościach podłączenia urządzeń perfyferyjnych (wsparcie dla: I2C, UART, SPI oraz inne).

ESP-WROOM-32 składa się z mikrokontrolera ESP32-D0WDQ6 posiadającego dwa rdzenie, które pozwają na prace od 80MHz do 240 MHz. Procesor również
posiada ko-procesor o niskim poborze mocy, który może zostać użyty zamiast głównych rdzeni w przypadku kiedy nie jest potrzebna duża moc obliczeniowa.

Integracja WIFI, Bluetooth i Bluetooth LE do mikrokontrolera pozwala na rozszerzenie możliwych zastosowań, gdzie nie jest możliwe podłączenie do sieci
w konwencjonalny spoób za pomocą kabla. Komunikacja bezprzewodowa również umożliwa całkowicie zdalne zastosowania z wykorzystaniem akumulatorów
oraz paneli słonecznych do zasilania mikrokontrolera.

\subsubsection{Specyfikacja ESP32}

\begin{table}[H]
    \centering
    \begin{tabular}{|l|l|}
        \hline
        Element & Specyfikacja \\
        \hline
        Procesor & 2 rdzenie (80-240MHz) \\
        \hline
        WIFI & 5802.11 b/g/n (802.11n: przepustowość 150 Mbps) \\
        \hline
        Bluetooth & Bluetooth v4.2 i Bluetooth LE \\
        \hline
        Pamięć SPI Flash & 4MB \\
        \hline
        Napięcie zasilania & 3.0 V - 3.6 V \\
        \hline
        Zużycie prądu & Średnie: 80 mA \\
        \hline
    \end{tabular}
    \caption{Najważniejsze specyfikacje ESP-WROOM-32}
    \label{esp32-spec}
\end{table}

Do realizacji projektu zostata wybrany mikrokontroler ESP-WROOM-32 ze względu na:

\begin{itemize}
    \item bogate możliwości podłączenia urządzeń perfyferyjnych
    \item wbudowane wspracie połączeń WIFI
    \item dużą ilość pamięci flash
    \item niewielką cenę w porównaniu do oferowanych specyfikacji
\end{itemize}

\bigskip
Potencjalnymi alternatywami, które nie zostały wybrane do realizacji projektu są:
\begin{itemize}
    \item Arduino Uno R3 (brak wbudowanej obsługi połączeń sieciowych)
    \item ESP8266 (wolniejszy procesor, mniejsza ilość pamięci flash, mniejsza ilosć wyprowadzeń do podłączenia urządzeń perfyferyjnych)
\end{itemize}

\subsection{Czujnik natężenia światła - TSL25911}

TSL25911 to czujnik światła z odpowiedzią podobną do ludzkiego oka. Posiada czułość 188 uLux oraz zakres dynamiczny 1 do 600,000,000.
W porównaniu do innych tańszych rozwiązań bazujących na fotokomórkach CdS, daje o wiele bardziej precyzujne rezultaty, z możliwością zmiany czułości i
rozdzielczości w locie. 

\subsubsection{Specyfikacja TSL25911}

\begin{table}[H]
    \centering
    \begin{tabular}{|l|l|}
        \hline
        Element & Specyfikacja \\
        \hline
        Rozdzielczość dynamiczna & 1 do 600,000,000 \\
        \hline
        Zakres pomiaru & 188 uLux - 88,000 Lux \\
        \hline
        Zakres temperatury pracy & -30 - 80 *C \\
        \hline
        Interfejs & I2C \\
        \hline
        Używane adresy I2C & 0x29 and 0x28 \\
        \hline
    \end{tabular}
    \caption{Specyfikacja TSL25911}
    \label{tsl25911-spec}
\end{table}

\subsubsection{Przykładowy program testu czujnika TSL25911}

\begin{code}[H]
    \inputminted[frame=lines,]{c}{../proj/tsl2591-test/tsl2591-test.ino}

    \caption{Test czujnika TSL25911}
    \label{diagnostic-data-code}
\end{code}

\subsection{Czujnik temperatury i wilgotności powietrza - DHT22}
// TODO

\subsection{Czujnik ciśnienia oraz temperatury - DPS310}
// TODO

\subsection{Czujnik światła ultrafioletowego - LTR390}

\section{Oprogramowanie}
// TODO

\subsection{Dostęp do danych przez przeglądarkę}
// TODO

\subsection{Dostęp do danych przez REST API}
// TODO

\subsection{Dostęp do danych diagnostycznych}

Urządzenie udostępnia dane, które mogą słuzyć do debugowania urządzenia za pomocą interfejsu szeregowego. W przypadku wykorzystanego w projekcie
mikrokontrolera po uruchomieniu urządzenia dane zostaną wysyłane również na port szeregowy oprócz reszty procesów do przetwarzania danych.

Funkcja \texttt{send\_debug\_info\_to\_serial} wysyła dane na interfejs szeregowy w postaci łatwej do przeczytania dla człowieka:

\begin{code}[H]
\begin{minted}[frame=lines,]{c}
    void send_debug_info_to_serial()
    {
        Serial.print(F("DHT22 sensor data - Temp: '"));
        Serial.print(current_reading_data.temperature);
        Serial.print(F("' Humidity: '"));
        Serial.print(current_reading_data.humidity);
        Serial.print(F("' Heat index: '"));
        Serial.print(current_reading_data.heat_index);
        Serial.println(F("'"));
    
        Serial.print(F("TSL2591 sensor data - Calculated Lux: '"));
        Serial.print(current_reading_data.calculated_lux);
        Serial.print(F("' Full spectrum light: '"));
        Serial.print(current_reading_data.full_spectrum_light);
        Serial.print(F("' Infrared light: '"));
        Serial.print(current_reading_data.infrared_light);
        Serial.print(F("' Visible light: '"));
        Serial.print(current_reading_data.visible_light);
        Serial.println(F("'"));
    
        Serial.print(F("DPS310 sensor data - Pressure: '"));
        Serial.print(current_reading_data.pressure);
        Serial.println(F("hPa'"));
    
        Serial.print(F("LTR390 sensor data - UVS: '"));
        Serial.print(current_reading_data.uvs);
        Serial.println(F("'"));
    
        Serial.println(F(""));
    }
\end{minted}
\caption{Kod dostępu do danych diagnostycznych}
\label{diagnostic-data-code}
\end{code}

Jako, że powyższa funkcja operuje na dużej ilość tekstu w sposób cały, zostało zastosowana optymalizacja w postaci użycia funkcji 
\texttt{F} - funkcja ta sprawia, że dany łańcuch znaków nie jest kopiowany do pamięci PSRAM mikrokontrolera przed wysłaniem na interfejs szeregowy, 
a dane są beźpośrednio kopiowane z programu do strumienia, który wysyłane dane na interfejs. 

\section{Testy}
// TODO

\section{Wnioski}
// TODO

\section{Literatura}

\printbibliography[heading=none]

\section{Spisy programów, tabel, fotografii}
\listoftables
\listof{code}{Spis programów}

\end{document}
